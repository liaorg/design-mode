## 工厂模式 - 创建型

> 1. 将 new 单独封装
> 2. 遇到 new 时考虑工厂模式
> 3. 简单工厂模式、工厂方法模式、抽象工厂模式

### 简单工厂

> 1. 定义一个创建对象的类，由这个类来封装实例化对象的行为
> 2. 简单工厂模式把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。
> 3. 优点：这样做能把客户类和具体子类的实现解耦，客户类不再需要知道哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类就要知道所有子类的细节，而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。
> 4. 缺点：
>     > 1. 工厂类集中了所有产品的创建逻辑，职责过重，一旦异常，整个系统将受影响。
>     > 2. 使用简单工厂模式会增加系统中类的个数(引入新的工厂类)，增加系统的复杂度和理解难度。
>     > 3. 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂。

> 5. 使用场景：
>     > 1. 工厂类负责创建的对象比较少，因为不会造成工厂方法中的业务逻辑过于复杂。
>     > 2. 客户端只知道传入工厂类的参数，对如何创建对象不关心。

### 工厂方法

> 1. 定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。
> 2. 优点：
>     > 1. 用户只需要关心产品对应的工厂，甚至无需关心创建细节或具体产品类的类名。
>     > 2. 能自主决定如何创建哪种产品对象，而创建细节都封装在具体工厂内部。
>     > 3. 在系统要添加新的产品时，无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其他的具体工厂和具体产品，只要添加一个具体工厂和具体产品即可，从而提高系统的可扩展性（符合开闭原则）。
> 3. 缺点：
>     > 1. 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。
>     > 2. 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。
> 4. 使用场景：
>     > 1. 所有需要生成对象的地方都可以使用（需要权衡是否需要增加一个工厂类，因为会增加代码的复杂度）
>     > 2. 需要灵活，可扩展的框架时
>     > 3. 在异构项目中使用
>     > 4. 在测试驱动开发的架构下

### 抽象工厂

> 1. 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类。
> 2. 优点：
>     1. 隔离了具体类的生成，使得客户端不需要知道什么被创建。依赖倒置原则
>     2. 当一个产品族的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族的对象。
>     3. 抽象工厂模式增加新的产品族很容易，无需修改已有系统，符合开闭原则。
> 3. 缺点：增加新的产品结构很麻烦，需要对原有系统进行大规模的修改，甚至需要修改抽象层代码，违背了开闭原则。
> 4. 使用场景：
>     1. 当一个系统不依赖于产品类实例如何被创建、组合和表达的细节，用户无需关心对象的创建过程，将对象的创建和使用解耦。
>     2. 系统中有多于一个的产品族，但每次只需要使用其中某一个产品族，可以通过配置文件等动态地改变产品族，也很方便的增加新的产品族。
>     3. 产品等级结构稳定，设计完成后，不会向系统增加新的产品等级结构或者删除已有的产品等级结构。
>     4. 适用于增加同类工厂这样的横向扩展需求，不适合新增功能这样的纵向扩展
